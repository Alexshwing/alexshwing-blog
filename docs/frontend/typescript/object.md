# 对象
## 一、简介
对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。
- 一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。
- 对象类型可以使用方括号读取属性的类型 `type Name = User['name']`
## 二、可选属性
如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。
- 可选属性等同于允许赋值为`undefined`
- 可选属性与允许设为`undefined`的必选属性是不等价的
  - 可选属性可以省略不写, 如何是允许设为`undefined`的必选属性, 一旦省略就会报错

## 三、只读属性
属性名前面加上`readonly`关键字，表示这个属性是只读属性，不能修改。
- 只读属性只能在对象初始化期间赋值，此后就不能修改该属性。
- 在赋值时，在对象后面加上只读断言`as const`也可以将属性值设置为只读。
- 如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。

## 四、属性名的索引类型
TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。

```ts
type T1 = {
  [property: string]: string
}

type T2 = {
  [property: number]: string
};

type T3 = {
  [property: symbol]: string
};
```
- 对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。
- 同样地，可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名符合属性名索引的范围，两者不能有冲突，否则报错。
- 属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及`length`属性

## 五、解构赋值
```ts
const {id, name, price} = product
```

## 六、结构类型原则

只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）。
```ts
const B = { x: 1, y: 1 }
const A: { x: number } = B; // 正确
```
> `B` 满足 `A` 的结构特征
>
> 根据"结构类型"原则, ts 检查某个值是否符合指定类型时, 并不是检查这个值的类型名(即"名义类型"), 而是检查这个值的结构是否符合要求(即"结构类型")


如果类型 B 可以赋值给类型 A，TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。

## 七、严格字面量检查
如果对象使用字面量表示, 会触发 ts 的严格字面量检查。如果字面量的结构跟类型定义的不一样(比如多出未定义的属性), 就会报错

如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。


```typescript
const point1:{
  x:number;
  y:number;
} = {
  x: 1,
  y: 1,
  z: 1 // 报错
};

const myPoint = {
  x: 1,
  y: 1,
  z: 1
};

const point2:{
  x:number;
  y:number;
} = myPoint; // 正确
```

## 八、最小可选属性原则
ts 2.4 引入"最小可选属性原则"(也称为"弱类型检测")。如果某个类型的所有属性都是可选的, 那么该类型的对象必须至少存在一个可选属性。

## 九、空对象
- 空对象是 TypeScript 的一种特殊值，也是一种特殊类型。
  - 空对象没有自定义属性，所以对自定义属性赋值就会报错。
  - 空对象只能使用继承的属性。
  - 空对象作为类型，其实是`Object`类型的简写形式。
```ts
const obj = {}
obj.prop = 123 // 报错
obj.toString() // 正确
let d: {} // 等同于 let d: Object
```